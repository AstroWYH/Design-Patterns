# Design-Patterns
常用设计模式知识整理，Head First设计模式（Java）的C++整理实现版，C++新经典设计模式整理----AstroWYH

### 00-HeadFirst/Duck

- 在Duck基类里，如果加上Fly行为，则会出现问题，因为不是所有的鸭子都会飞，比如如果RedHeadDuck不会飞的话，则其也具有了Fly行为，这是不对的。而Swim行为则没问题，因为所有的鸭子都会游泳。而Quack和Fly类似。
- 基于上述考虑，如果直接将Fly行为从Duck类中抽出，将其作为接口（interface，C++中用只含纯虚函数的类表示），每个Duck的子类实现（implement）该接口，则代码的复用性很差。比如一共有50种不同鸭子的子类，其中20种子类里写了某种Fly，比如FlyWithWings，另外30种子类里写了另一种Fly，比如FlyNoWay，则相当于重复的代码写了20次+30次。
- 基于上述考虑，将Fly这种行为再进行抽象一层。如FlyBehavior作为接口，提供Fly函数，而FlyWithWings作为一个类实现该接口，其内实现Fly；同理，FlyNoWay作为另一个类实现Fly。并将FlyBehavior接口的引用（C++中用unique_ptr即可）放入Duck父类，如此一来，每个Duck子类只需要在构造时，对从Duck父类继承到的FlyBehavior，进行赋值即可（多态的体现，父类指针/引用指向子类对象）。这样，20次+30次的重复代码就没有了，代码复用性提高。
- 系统设计时，总会有不变+会变的两部分，需将不变+会变拆分。
- 针对接口编程，而不是针对实现编程。

### 01-模板方法模式

- 设计模式的作用就是**在变化和稳定中间寻找隔离点**，去**分离稳定和变化**，从而**管理变化**。
- 但如果整个设计中导出都是变化或者到处都稳定，那么自然也就不需要使用任何设计模式了。
- 模板方法模式的关键：父类Fitghter的Burn()中有**几个非常固定成员函数**调用：EffectEnemy()、EffectSelf()、Show()。这是非常稳定的结构（也是模板方法的由来），前两个的具体实现交给子类，最后一个则是父类自己实现。

### 02-简单工厂模式

- **开闭原则：对扩展开放，对修改关闭。**
- 实现了将创建怪物的代码，和怪物类对象要实现的业务逻辑相**隔离**，实现了**封装变化**。
- 避免将依赖遍布整个代码，提高了代码的可维护性和可扩展性，避免一修改代码就要修改一大片的困境。
- 希望能够创建一个对象，但创建过程比较复杂，希望对外**隐藏这些细节**。
- 一个怪物工厂，生产3种怪物。如果增加怪物，则需要修改CreateMonster()，**违反开闭原则**。

### 03-工厂方法模式

- 工厂方法模式是**使用频率最高**的工厂模式，又叫**工厂模式**或**多态工厂模式**。
- 有些人将简单工厂模式看做工厂方法模式的特例；抽象工厂模式见外层md，这里不详细再写。
- 3个怪物工厂，分别生产3种怪物。当有**新的怪物**诞生时，需要**新增对应的工厂类**，满足开闭原则。
- 除怪物类外，工厂类也有父类和多个子类（和怪物类一一对应）。
- 抽象工厂模式的核心：由于工厂方法模式每增加一种怪物子类，就要增加一种工厂子类，导致工厂子类数量太多。因此，如果**一个工厂子类能够生产多种怪物**（这多种怪物具有相似规则），那么就能有效减少工厂子类的数量，这就是抽象工厂模式的核心思想！
- 比如一个城镇工厂子类可生产：城镇亡灵怪、城镇元素怪、城镇机械怪。

### 04-建造者模式

- 建造者模式通常用来**创建**一个**比较复杂**的对象，改对象的创建一般分一定的步骤顺序执行。
- 比如本例中，创建一个怪物，需要**组装躯干、头部、四肢**。这部分代码是**稳定**的，不发生变化。
- 将LoadTrunkModel()、LoadHeadModel()、LoadLimbsModel()这些创建载入相关成员函数成为**构建过程的相关函数**，考虑到Monster类中要实现的其他功能可能还较多，因此将这部分成员函数提取（分离）到**单独一个类**中（MonsterBuilder类，并根据Monster子类各自创建相应子类），不但可以减少Monster类代码量，还增加构建过程的独立性。日后游戏中任何躯干、头部、四肢的组装，都可单独通过该类。
- MonsterDirector是指挥者类，其内部封装MonsterBuilder的指针，其Conduct()中依次调用builder的LoadTrunkModel()、LoadHeadModel()、LoadLimbsModel()的组装流程，扮演指挥者的作用。

### 05-适配器模式

- LogToFile是代码中原先直接记录log到文件的类。
- LogToDB是后来随着工程的扩张，代码越来越多，于是将log从文件记录到DB中。
- 然而有一次，DB损坏了，必须要使用原来的LogToFile，但此时很多db->xxx()这样的代码**如果全部修改**，则**代价太大**。
- 因此引入LogToAdapter类作为适配层，将其作为LogToDB的子类，在其内封装LogToDB的指针，在其子类各函数中实现LogToFile的实际操作。
- 可以看到，经过**适配**，极大地**减少了代码的改动**。